server {
    listen       8088;
    server_name  _;

    # Root points to Angular build output
    root   /usr/share/nginx/html;
    index  index.html;

    # Proxy API calls to backend service
    location /graphql {
        access_log /dev/stdout upstream_logging;
        error_log /dev/stderr debug;

        # Use variable for dynamic DNS resolution
        set $upstream http://bff-service.stage-palazzi.svc.cluster.local:8085/graphql;

        # DNS resolver - use the cluster DNS service IP
        resolver 172.30.0.10 valid=30s;

        proxy_pass         $upstream;
        proxy_http_version 1.1;

        # Pass through all headers from the original request
        proxy_set_header   Host $http_host;
        proxy_set_header   X-Real-IP $remote_addr;
        proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header   X-Forwarded-Proto $scheme;
        proxy_set_header   X-Forwarded-Host $host;
        proxy_set_header   X-Forwarded-Port $server_port;

        # WebSocket support
        proxy_set_header   Upgrade $http_upgrade;
        proxy_set_header   Connection 'upgrade';
        proxy_cache_bypass $http_upgrade;

        # Authentication headers - pass through all auth-related headers
        proxy_set_header   Authorization $http_authorization;
        proxy_set_header   Cookie $http_cookie;

        # Pass through any custom headers the frontend might be sending
        proxy_pass_request_headers on;
    }

    # Proxy /api/* calls to BFF service
    location /api/ {
        access_log /dev/stdout upstream_logging;
        error_log /dev/stderr debug;

        # Use variable for dynamic DNS resolution
        set $upstream http://bff-service.stage-palazzi.svc.cluster.local:8085;

        # DNS resolver - use the cluster DNS service IP
        resolver 172.30.0.10 valid=30s;

        # Proxy the request to BFF
        #proxy_pass         $upstream/api/$1$is_args$args;
        proxy_pass         $upstream$request_uri;
        proxy_http_version 1.1;

        # Pass through all headers from the original request
        proxy_set_header   Host $http_host;
        proxy_set_header   X-Real-IP $remote_addr;
        proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header   X-Forwarded-Proto $scheme;
        proxy_set_header   X-Forwarded-Host $host;
        proxy_set_header   X-Forwarded-Port $server_port;

        # WebSocket support
        proxy_set_header   Upgrade $http_upgrade;
        proxy_set_header   Connection 'upgrade';
        proxy_cache_bypass $http_upgrade;

        # Authentication headers - pass through all auth-related headers
        proxy_set_header   Authorization $http_authorization;
        proxy_set_header   Cookie $http_cookie;

        # Pass through any custom headers the frontend might be sending
        proxy_pass_request_headers on;
    }

    # Health check endpoint
    location /health {
        access_log off;
        return 200 "healthy\n";
        add_header Content-Type text/plain;
    }

    # Optional: serve static assets with caching
    location ~* \.(?:ico|css|js|gif|jpe?g|png|woff2?|eot|ttf|svg)$ {
        expires 6M;
        access_log off;
        add_header Cache-Control "public";
    }

    # Serve Angular app
    location / {
        try_files $uri $uri/ /index.html;
    }
}
